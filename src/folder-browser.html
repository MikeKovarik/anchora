<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<style>
		@media only screen and (max-width: 499px) {
			html {
				font-size: 16px;
			}
		}
		@media only screen and (min-width: 500px) {
			html {
				font-size: 24px;
			}
		}
		html,
		body {
			padding: 0;
			margin: 0;
		}
		body {
			font-family: sans-serif;
			font-size: 16px;
			padding: 1rem;
		}
		a {
			text-decoration: none;
			color: #000;
		}


		[icon]::before {
			content: '';
			display: inline-block;
			font-size: var(--size);
			line-height: var(--size);
			width: var(--size);
			height: var(--size);
		}
		[fluent] [icon]::before {
			font-family: Segoe MDL2 Assets, Symbols, Segoe UI, sans-serif;
		}
		[fluent] [icon] {
			--size: 16px;
		}
		[material] [icon] {
			--size: 24px;
		}
		/* Windows Fluent Design / Segoe UI Icons */
		[fluent] [icon="folder"]::before {
			content: '\E8B7';
		}
		[fluent] [icon="file"]::before {
			content: '\E7C3';
		}
		/* Android Material Design Icons */
		[material] [icon="folder"]::before {
			background-image: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22%23757575%22%3E%3Cpath%20d%3D%22M20%2C6h-8l-2-2H4C2.9%2C4%2C2.01%2C4.9%2C2.01%2C6L2%2C18c0%2C1.1%2C0.9%2C2%2C2%2C2h16c1.1%2C0%2C2-0.9%2C2-2V8C22%2C6.9%2C21.1%2C6%2C20%2C6z%20M20%2C18H4V8h16V18z%22%2F%3E%3C%2Fsvg%3E')
		}
		[material] [icon="file"]::before {
			background-image: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22%23757575%22%3E%3Cpath%20id%3D%22XMLID_339_%22%20d%3D%22M14%2C2H6C4.9%2C2%2C4.01%2C2.9%2C4.01%2C4L4%2C20c0%2C1.1%2C0.89%2C2%2C1.99%2C2H18c1.1%2C0%2C2-0.9%2C2-2V8L14%2C2z%20M6%2C20V4h7v5h5v11L6%2C20z%22%2F%3E%3C%2Fsvg%3E')
		}
		[material] [icon="cert"]::before {
			background-image: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22%23757575%22%3E%3Cpath%20d%3D%22M4%2C3C2.89%2C3%202%2C3.89%202%2C5V15A2%2C2%200%200%2C0%204%2C17H12V22L15%2C19L18%2C22V17H20A2%2C2%200%200%2C0%2022%2C15V8L22%2C6V5A2%2C2%200%200%2C0%2020%2C3H16V3H4M12%2C5L15%2C7L18%2C5V8.5L21%2C10L18%2C11.5V15L15%2C13L12%2C15V11.5L9%2C10L12%2C8.5V5M4%2C5H9V7H4V5M4%2C9H7V11H4V9M4%2C13H9V15H4V13Z%22%20%2F%3E%3C%2Fsvg%3E')
		}
		[material] [icon="search"]::before {
			background-image: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22%23757575%22%3E%3Cpath%20d%3D%22M15.5%2C14h-0.79l-0.28-0.27C15.41%2C12.59%2C16%2C11.11%2C16%2C9.5C16%2C5.91%2C13.09%2C3%2C9.5%2C3S3%2C5.91%2C3%2C9.5S5.91%2C16%2C9.5%2C16c1.61%2C0%2C3.09-0.59%2C4.23-1.57L14%2C14.71v0.79l5%2C4.99L20.49%2C19L15.5%2C14z%20M9.5%2C14C7.01%2C14%2C5%2C11.99%2C5%2C9.5S7.01%2C5%2C9.5%2C5S14%2C7.01%2C14%2C9.5S11.99%2C14%2C9.5%2C14z%22%20%2F%3E%3C%2Fsvg%3E')
		}


		[secondary] {
			color: #757575;
			font-size: 14px;
			line-height: 16px;
		}
		[fx-item] {
			margin: 0 -1rem;
			padding: 0 1rem;
			display: flex;
			line-height: 18px;
			position: relative;
		}
		.header {
			font-weight: 700;
		}
			.header > * {
				cursor: pointer;
			}

		[touch][material] [fx-item] {
			border-top: 1px solid #EEE;
			min-height: 40px;
			font-size: 16px;
			padding-top: 0.5rem;
			padding-bottom: 0.5rem;
		}
		@media only screen and (max-width: 499px) {
			[fx-item] {
				border-top: 1px solid #EEE;
				min-height: 40px;
				font-size: 16px;
				padding-top: 0.5rem;
				padding-bottom: 0.5rem;
			}
			.header {
				display: none;
			}
			body:not([touch]) .shapeshift {
				display: none;
			}
			[fx-item] {
				flex-direction: column;
				align-items: flex-start;
				justify-content: center;
			}
			[fx-item][icon] {
				padding-left: calc(2rem + var(--size));
			}
				[fx-item][icon]::before {
					position: absolute;
					left: 1rem;
					top: 50%;
					margin-top: calc(-1 * var(--size) / 2);
				}
		}
		@media only screen and (min-width: 500px) {
			body:not([material]) [fx-item],
			body:not([touch]):not([material]) [fx-item] {
				max-width: 750px;
			}
			[fx-item] {
				align-items: center;
				font-size: 15px;
				min-height: 26px;
			}
				[fx-item] > * + * {
					margin-left: 1rem;
				}
				[fx-item][icon]::before {
					margin-right: 0.5rem;
				}
			.name {
				flex: 2;
			}
			.shapeshift {
				display: flex;
				flex: 1;
			}
			.header .name {
				flex: 5;
			}
				.size,
				.modified {
					flex: 1;
				}
				.modified {
					text-align: right;
				}
		}

		#toolbar {
			position: relative;
			margin-top: 0;
			margin-bottom: 0.75rem;
			margin: -1rem -1rem 0 -1rem;
		}
		#toolbar,
		#toolbar input {
			font-weight: 300;
			font-size: 24px;
		}
			#toolbar > * {
				padding: 1rem 1rem 16px 1rem;
			}
			#toolbar #search {
				background-color: #FFF;
			}
			#toolbar #search:not(.visible) {
				opacity: 0;
				pointer-events: none;
			}
			#toolbar #search,
			#toolbar #search input {
				position: absolute;
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;
			}
				#toolbar #search input {
					background-color: transparent;
					width: 100%;
					outline: none;
					border: none;
					padding: 1rem 1rem 16px calc(1rem + 16px);
				}
			#toolbar #breadcrumbs {
				padding: 1rem 1rem 16px 1rem;
				white-space: nowrap;
				overflow-x: auto;
			}
				#breadcrumbs > * + * {
					margin-left: 0.5rem;
				}
	</style>
	<title>Anchora static server</title>
</head>
<body>

	<div id="toolbar">
		<div id="search">
			./
			<input type="search">
		</div>
		<div id="breadcrumbs"></div>
	</div>

	<div fx-item class="header">
		<div class="orderby name">Name</div>
		<div class="orderby size">Size</div>
		<div class="orderby modified">Modified</div>
	</div>

	<div id="list"></div>


	<script>
		var initState /* TO BE ADDED BY SERVER HERE */
	</script>
	<script>

		// UI SETUP

		if (navigator.maxTouchPoints > 0)
			document.body.setAttribute('touch', '')
		if (navigator.userAgent.includes('Windows'))
			document.body.setAttribute('fluent', '')
		else
			document.body.setAttribute('material', '')

		// APP SETUP

		var $breadcrumbs = document.querySelector('#breadcrumbs')
		var $searchInput = document.querySelector('#search input')
		var $search = document.querySelector('#search')
		var $list = document.querySelector('#list')
		var currentOrderBy
		var currentOrderDirection = true

		class MapStore extends Map {
			store(state) {
				this.set(state.url, state)
			}
		}
		var stateCache = new MapStore

		// On navigation back
		window.addEventListener('popstate', onPopState)

		// Handle clicking and initiate navigation if link is clicked.
		document.addEventListener('click', async e => {
			handleLinkClick(e)
			handleSortClick(e)
		})

		window.addEventListener('keydown', onKeyDown)
		$searchInput.addEventListener('input', onSearchChange)

		// Add initial data state onto history navigation stack
		loadInitState()

		// CLICK HANDLERS

		function handleLinkClick(e) {
			var node = e.target
			while (node) {
				if (node.localName === 'a')
					break
				node = node.parentElement
			}
			if (!node)
				return
			if (!node.hasAttribute('preventable'))
				return
			e.preventDefault()
			navigate(node.href)
		}

		function handleSortClick(e) {
			if (e.target.classList.contains('orderby'))
				renderList(undefined, e.target.className.split(' ')[1])
		}

		// SEARCH HANDLERS

		var KEYCODE = {
			BACKSPACE: 8,
			TAB: 9,
			ENTER: 13,
			ESC: 27,
		}

		function onKeyDown(e) {
			// Go to first item if enter key is pressed.
			var {keyCode} = e
			var searchVal = $searchInput.value
			if (keyCode === KEYCODE.ENTER && searchVal) {
				e.preventDefault()
				var node = $list.firstElementChild
				if (node && node.textContent.trim() === '../')
				node = node.nextElementSibling
				if (node)
				node.click()
			} else if (keyCode === KEYCODE.ESC) {
				e.preventDefault()
				$searchInput.value = ''
				onSearchChange()
			} else if (keyCode === KEYCODE.BACKSPACE && !isSearchInputFocused()) {
				e.preventDefault()
				navigate(createParentUrl(location.pathname))
			} else if (document.activeElement !== $searchInput) {
				// Only select search input if its not focused already.
				$searchInput.focus()
			}
			// TODO add search
		}

		function onSearchChange(e) {
			var searchVal = $searchInput.value
			if (searchVal.length)
				$search.classList.add('visible')
			else
				$search.classList.remove('visible')
			renderList()
		}

		function isSearchInputFocused() {
			return $searchInput === document.activeElement
				&& $search.classList.contains('visible')
		}

		// NAVIGATION AND RENDERING

		function loadInitState() {
			if (typeof initState === 'undefined') return
			let state = initState
			let {url} = state
			stateCache.store(state)
			history.replaceState(url, undefined, url)
			renderState(state, true)
		}

		// Loads currently stored (if any) state and silently download and render fresh data.
		async function loadCachedState(url) {
			var resetScroll = true
			// Try to render cached state
			var cachedState = stateCache.get(url)
			if (cachedState) {
				renderState(cachedState, resetScroll)
				// State has been rendered with cached data, ensure the scroll won't be reset
				// once the fresh data will download and render in a moment.
				resetScroll = false
			}
			// Start downloading fresh data in meantime.
			let freshState = await fetchJson(url)
			stateCache.store(freshState)
			// Render fresh data if the state url is still opened.
			if (history.state === url)
				renderState(freshState, resetScroll)
		}

		async function onPopState(e) {
			// Load currently stored (if any) state and also silently download and render fresh data.
			loadCachedState(history.state)
		}

		// Fetch data for given url and render retrieved data.
		async function navigate(url) {
			url = sanitizeUrl(url)
			// Add new data state onto history navigation stack.
			history.pushState(url, undefined, url)
			// Load currently stored (if any) state and also silently download and render fresh data.
			loadCachedState(url)
		}

		// Render given state into DOM.
		function renderState(state, resetScroll = false) {
			document.title = state.url
			// Reset search input.
			$searchInput.value = ''
			// Render DOM
			renderBreadcrumbs(state)
			renderList(state)
			// Resetting scroll positions is a fucking disaster. Each browser has different quirks.
			if (resetScroll) {
				$breadcrumbs.scrollLeft = 1000000
				document.body.scrollTop = 0
				document.documentElement.scrollTop = 0
				setTimeout(() => $breadcrumbs.scrollLeft = 1000000)
				setTimeout(() => document.body.scrollTop = 0)
				setTimeout(() => document.documentElement.scrollTop = 0)
			}
		}

		function renderBreadcrumbs(state) {
			var {url, descriptors} = state
			var sections = url.slice(1).split('/')
			var breadcrumbs = sections
				.map((name, i) => `<a preventable href="/${sections.slice(0, i + 1).join('/')}">${name}</a>`)
				.join('<span>/</span>')
			$breadcrumbs.innerHTML = `<a preventable href="/">localhost</a><span>/</span>` + breadcrumbs
		}

		function renderRow(desc) {
			var {name, size, mtimeMs, url, file, folder} = desc
			size = size !== undefined && file ? formatBytes(size) : ''
			if (mtimeMs && file) {
				var modified = (new Date(mtimeMs)).toLocaleDateString()
			} else {
				var modified = ''
			}
			if (folder) {
				if (!name.endsWith('/'))	name += '/'
				if (!url.endsWith('/'))		url += '/'
			}
			return `
			<a fx-item
			icon="${desc.file ? 'file' : 'folder'}"
			${folder && 'preventable'}
			href="${url}">
				<span class="name">${name}</span>
				<span class="shapeshift" secondary>
					<span class="size">${size}</span>
					<span class="modified">${modified}</span>
				</span>
			</a>`
		}

		function renderList(state, orderBy, filterBy) {
			if (!state)
				state = stateCache.get(history.state)
			var {url, descriptors} = state
			var files = descriptors.filter(desc => desc.file)
			var folders = descriptors.filter(desc => desc.folder)
			var sorted = [...folders, ...files]
			if (orderBy) {
				if (orderBy === currentOrderBy)
					currentOrderDirection = !currentOrderDirection
				else
					currentOrderDirection = true
				if (orderBy === 'name') {
					if (currentOrderDirection)
						sorted.sort((a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1)
					else
						sorted.sort((a, b) => b.name.toLowerCase() < a.name.toLowerCase() ? -1 : 1)
				} else {
					if (currentOrderDirection)
						sorted.sort((a, b) => a[orderBy] - b[orderBy])
					else
						sorted.sort((a, b) => b[orderBy] - a[orderBy])
				}
				currentOrderBy = orderBy
			}
			if (!filterBy)
				filterBy = $searchInput.value
			if (filterBy) {
				filterBy = filterBy.toLowerCase().trim()
				sorted = sorted.filter(item => item.name.toLowerCase().includes(filterBy))
			}
			if (url !== '/') {
				if (url.endsWith('/'))
					url = url.slice(0, -1)
				var parentUrl = createParentUrl(url)
				sorted.unshift({
					name: '..',
					url: parentUrl,
					folder: true,
				})
			}
			$list.innerHTML = sorted.map(renderRow).join('\n')
		}

		// UTILITIES

		// Fetch directory url in JSON form.
		async function fetchJson(url) {
			var state = await fetch(url + '?anchora=json').then(res => res.json())
			stateCache.store(state)
			return state
		}
		async function fetchJson(url) {
			//var state = await fetch(url + '?anchora=json').then(res => res.json())
			var res = await fetch(url + '?anchora=json')
			if (res.headers.get('content-type') !== 'application/json')
				window.location.href = url
			var state = await res.json()
			stateCache.store(state)
			return state
		}

		function createParentUrl(url) {
			//new URL('../', url).href
			if (url.endsWith('/'))
				url = url.slice(0, -1)
			var lastSlashIndex = url.lastIndexOf('/')
			var parentUrl = url.slice(0, lastSlashIndex)
			if (parentUrl.endsWith('/'))
				return parentUrl
			else
				return parentUrl + '/'
		}

		// Ensures we only use abslute path without protocol and localhost (strip http://localhost and only keep /sub/path/to...).
		function sanitizeUrl(url) {
			return (new URL(url, location.origin)).pathname
		}

		// Format bytes into easier readable formats (B, kB, MB, etc...).
		function formatBytes(bytes, decimals = 2) {
			if (bytes === 0)
				return '0 B'
		    var sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
		    var i = Math.floor(Math.log(bytes) / Math.log(1024))
			return parseFloat((bytes / Math.pow(1024, i)).toFixed(decimals)) + ' ' + sizes[i]
		}
	</script>

</body>
</html>